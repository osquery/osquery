# Process and socket auditing with osquery

Enabling these auditing features requires additional configuration of osquery. osquery can leverage either BPF, Audit, OpenBSM or EndpointSecurity subsystems to record process executions and network connections in near real-time on Linux and macOS systems. Although these auditing features are extremely powerful for recording the activity from a host, they may introduce additional CPU overhead and greatly increase the number of log events generated by osquery.

To read more about how event-based tables are created and designed, check out the osquery [Table Pubsub Framework](../development/pubsub-framework.md).

Because different platforms have different choices for collecting real-time event data, osquery has multiple tables to present this information depending on the source and platform:

| Event type | osquery Table | Source | Supported Platform |
| -------------- | -------- | -------- | -------- |
| Process events | [`process_events`](https://osquery.io/schema/current#process_events)    | Audit (Linux), OpenBSM (macOS)  | Linux, macOS (10.15 and older) |
| Process events | [`bpf_process_events`](https://osquery.io/schema/current#bpf_process_events) | BPF | Linux (kernel 4.18 and newer) |
| Process events | [`es_process_events`](https://osquery.io/schema/current#es_process_events) | EndpointSecurity | macOS (10.15 and newer) |
| Security events | [`es_security_events`](https://osquery.io/schema/current#es_security_events) | EndpointSecurity | macOS (10.15 and newer) |
| Socket events  | [`socket_events`](https://osquery.io/schema/current#process_events)      | Audit (Linux), OpenBSM (macOS) | Linux, macOS (10.15 and older) |
| Socket events  | [`bpf_socket_events`](https://osquery.io/schema/current#bpf_socket_events) | BPF | Linux (kernel 4.18 and newer) |

To collect process events, you would add a query like the following to your query schedule, or to a query pack:

```sql
SELECT * FROM process_events;
```

Each of these auditing features is enabled on a per-source basis using additional osquery configuration settings. Enabling any of them may have performance impact depending on the host activity, and should be tested in your environment before deployment. See the OS-specific sections for guidance.

## General Troubleshooting

Though some testing of underlying operating system configuration can
be performed via `osqueryi`; `osqueryi` and `osqueryd` operate
independently and do not communicate.

The `--verbose` flag can be really useful when trying to debug a problem.

### Examine configuration flags

To verify that osquery's flags are set correct, you can query the
`osquery_flags` table. For example, on a macOS machine, this shows
osquery will process OpenBSM events.

```sql
osquery> select * from osquery_flags where name in ("disable_events", "disable_audit");
+----------------+------+---------------------------------------------------+---------------+-------+------------+
| name           | type | description                                       | default_value | value | shell_only |
+----------------+------+---------------------------------------------------+---------------+-------+------------+
| disable_audit  | bool | Disable receiving events from the audit subsystem | true          | false | 0          |
| disable_events | bool | Disable osquery publish/subscribe system          | false         | false | 0          |
+----------------+------+---------------------------------------------------+---------------+-------+------------+
```

### Examine event table

To verify that osquery can capture events, you can query the process_events table itself.

```
osquery> select * from process_events limit 1;
+------------+------+-------+--------+----------+----------+--------+---------+---------+--------+------+-------+------------+
| pid        | path | cmdline | cmdline_size | uid | gid | euid | egid | owner_uid | owner_gid | env | env_count | env_size |
+------------+------+-------+--------+----------+----------+--------+---------+---------+--------+------+-------+------------+
| 30321      | /usr/bin/ls | /usr/bin/ls | 12     | 1000     | 1000     | 1000   | 1000    | 0        | 0       |  | 0     | 0        |
+------------+------+-------+--------+----------+----------+--------+---------+---------+--------+------+-------+------------+
```

If you're trying to capture network (socket) events, create a socket to test:

```sh
bash # start a root shell
password: ******
curl google.com
```

```
osquery> select * from socket_events;
```

## Tuning the event system

### Improving performance through optimizations and filtering

This section provides a brief overview of common and recommended
optimizations for event-based tables. These optimizations also apply
to the FIM events.

1. `--events_optimize=true` apply optimizations when `SELECT`ing from events-based tables, enabled by default.
2. `--events_expiry` the lifetime of buffered events in seconds with a default value of 86000.
3. `--events_max` the maximum number of events to store in the buffer before expiring them with a default value of 1000.

The goal of optimizations are to protect the running process and system from impacting performance. By default these are all enabled, which is good for configuration and performance, but may introduce inconsistencies on highly-stressed systems using process auditing.

Optimizations work best when `SELECT`ing often from event-based tables. Otherwise the events are in a buffered state. When an event-based table is selected within the daemon, the backing storage maintaining event data is cleared according to the `--event_expiry` lifetime. Setting this value to `1` will auto-clear events whenever a `SELECT` is performed against the table, reducing all impact of the buffer.

## Linux process and socket auditing with Audit

On Linux, osquery can use the Audit event publisher to process events from the kernel's audit subsystem. For process-related events, the publisher builds events from the following message types: `SYSCALL`, `EXECVE`, `FORK/VFORK/CLONE`, `CRED_ACQ`, `CRED_DISP`, `EXIT`, `SOCKADDR`. Some of these message types are only available in recent versions of the Linux kernel.

The process events come mostly from the `SYSCALL` (syscalls `execve`, `fork`, and `clone`) message types. These are compared and correlated with other tables for executing `path` and `cmdline`.

Table: `process_events`

| Fields  | Type | Description |
| ------- | ---- | ----------- |
| auid  | INTEGER | Authentication (user) ID. |
| status | INTEGER | Status of the process event. |
| atime | INTEGER | UNIX time at which the process was started. |
| cmdline | TEXT | Full command line of the process. |
| cwd | TEXT | String representing process's current working directory. |
| parent  | INTEGER | Process ID of the parent process. |
| pid  | INTEGER | Process ID. |
| path  | TEXT | Path of executed file. |
| syscall  | TEXT | The syscall which caused this event.|

Socket events occur via the `SOCKADDR` message type. osquery uses the events to maintain tables similiar to the following:

Table: `socket_events`

| Fields  | Type | Description |
| ------- | ---- | ----------- |
| auid  | INTEGER | Authentication (user) ID. |
| status | INTEGER | Status of the network connect/bind event. |
| atime | INTEGER | UNIX time at which the connection/binding was observed. |
| success  | INTEGER | True if the connect/bind system call was successful. |
| family  | INTEGER | The Internet protocol family ID. |
| protocol  | INTEGER | The protocol ID (given protocol family). |
| local_address  | TEXT | Local address associated with the socket connection/binding. |
| remote_address  | TEXT | Remote address associated with the socket connection. |
| local_port  | INTEGER | Local port associated with the socket connection/binding. |
| remote_port  | INTEGER | Remote port associated with the socket connection. |
| socket_path  | TEXT | The local path (UNIX domain socket). |

Both of these tables require the following flags/options to be enabled:

```sh
sudo osqueryd \
  --disable_events=false \
  --disable_audit=false
```

If you are running with the schedule enabled, you should see events similar to the following in the osquery logs:

```
I0916 13:30:25.068559 1605089 events.cpp:956] Event publisher failed setup: auditeventpublisher: You do not have permission to subscribe to audit events
```

This is due to restrictions the kernel places on connections to its audit subsystem. You can disable the publisher safely if you do not need process/socket events:

```
--disable_audit=true
```

But if you'd like to log process events, and are running as a non-privileged user, you need to make sure the appropriate rules are added and that the user has permission to connect.

A more expected error is:

```
I0916 13:40:12.578583 1613985 events.cpp:925] Unable to add audit EventPublisher: Cannot access the Audit subsystem
```

which indicates that the osquery user does not have enough privileges to interact with the audit subsystem. With recent kernels, the `CAP_AUDIT_CONTROL` capability is required to add audit rules or run osquery with the `--disable_audit=false` flag. It can be added with:

```
sudo setcap 'cap_audit_control=ep' /usr/bin/osqueryd
```

Or, run it as root, and with `--allow_root`.

### Linux audit rules

After you add the following rules (or similar) to your audit configuration:

```
# /etc/audit/audit.rules
# Add rules for events you care about.
# Process events
-a exit,always -F arch=b64 -S execve,execveat,fork,vfork,clone -k process_events
# Socket events
-a exit,always -F arch=b64 -S connect,bind -k socket_events
```

Restart the audit service:
```
service auditd restart
```

Check that the rules have been loaded with:
```
auditctl -l
```

If you would like a less verbose audit log, try the following flags:
```
-a exit,never -F arch=b64 -S connect -F success=0
-a exit,never -F arch=b64 -S bind -F success=0
```

If you are having trouble and want to get raw telemetry of what the Audit subsystem is emitting, you can also check the output of audit directly. In recent distributions like CentOS, you can do this via:
```
ausearch --start=today --raw | aureport -i
```

In some Linux distributions (e.g., CentOS), you may need to install the audit packages via:
```sh
yum install audit
```

If reading from the audit service gives you trouble, try reloading and saving the rules manually:
```
sudo auditctl -R /etc/audit/audit.rules
```

In some Linux distributions (e.g., CentOS), the audit rules persist separate from the audit daemon. If you are experiencing trouble from `auditd`, you may modify the service and run the `auditctl` daemon too:
```
sudo auditctl -R /etc/audit/audit.rules
```

### Throttling the Audit publisher in high event volume situations

When using the Audit publisher on Linux in environments with high events volume, it's possible for the internal Audit library to indicate "throttling" is happening.
If this happens, a message will be logged which is the following:
`The Audit publisher has throttled record reading for <N> seconds. This may cause loss of events.`

This means that the Audit publisher is receiving events at a rate that is too high for it to process in a way that doesn't allocate unbounded memory. The consequence of throttling is that osquery allocates a constant amount of memory during the throttling window, however this might also mean that the Audit socket buffer size may be overrun, losing audit records.

You can check if this is happening looking at the `lost` field via `auditctl -s`.

Throttling currently starts when more than 4096 records have been read and are still in the queue to be processed by osquery; this is a number of records
which can support high spikes of events, and is a limit for osquery to avoid consuming memory indefinitely.  
Keep in mind that if the high rate of events continues, even with throttling happening, you might still have to increase your default [watchdog memory limit](../installation/cli-flags.md#daemon-control-flags) or reduce the interval of the scheduled query on the evented table, due to the amount of rows that it will have to generate at once.

There's also a second throttling point in the Audit publisher pipeline, which exists after the records have been read from the Netlink socket and are then parsed into a more computer friendly format.  
When throttling happens here, another message will be logged which is:  
`The Audit publisher has throttled record processing for <N> seconds. This may cause further throttling and loss of events.`.

This message exists mostly for debugging purposes and will only appear if `--verbose` is active, because this doesn't necessarily cause loss of events: a bottleneck in this point of the pipeline will have to cause throttling in the Netlink socket reading side, before possibly causing loss of events.  
So as long as no throttling is happening on the reading side, no loss of events should happen due to this.

To avoid throttling there isn't much to be done beyond reducing constraints on the CPU or in general have osquery process less events.

To attempt avoiding losing events, first of all we should ensure that throttling happens as few times as possible. Then when can try to increase the backlog buffer that the Audit subsystem is using via the `--audit_backlog_limit` flag, to attempt to support bigger/slightly longer events spikes.  
Keep in mind that increasing this will increase the amount of memory used by the Audit subsystem and that this memory is not allocated by osquery, so it won't be accounted for by the watchdog.

## User event auditing with Audit

On Linux, a companion table called `user_events` is included that provides several authentication-based events. If you are enabling process auditing it should be trivial to also include this table.

## Linux process and socket auditing using BPF

When osquery is running on a recent kernel (>= 4.18), the BPF eventing framework can be used. This event publisher needs to monitor for more system calls to reach feature parity with the Audit-based tables. For this reason, enabling BPF will also enable both the `bpf_process_events` and `bpf_socket_events` tables.

In order to start the publisher and enable the subscribers, the following flags must be passed: `--disable_events=false --enable_bpf_events=true`. The `--verbose` flag can also be extremely useful when setting up the configuration for the first time, since it emit more debug information when something fails.

The BPF framework will make use of a perf event array and several per-cpu maps in order to receive events and correctly capture strings and buffers. These structures can be configured using the following command line flags:

- **bpf_perf_event_array_exp**: size of the perf event array, as a power of two
- **bpf_buffer_storage_size**: how many slots of 4096 bytes should be available in each memory pool

Memory usage depends on both:

 1. How many processors are currently online
 2. How many processors can be added by hotswapping

The BPF event publisher uses 6 memory pools, grouping system calls in order to evenly distribute memory usage. Not counting the internal maps used to merge sys_enter/sys_exit events (the size for these maps is rather small), memory usage can be easily estimated with the following formula:

```cpp
buffer_storage_bytes = memory_pool_count * (bpf_buffer_storage_size * 4096) * possible_cpu_count
```

```cpp
perf_bytes = (2 ^ bpf_perf_event_array_exp) * online_cpu_count
```

The cpu count numbers can be read from the `/sys` folder:

 1. `/sys/devices/system/cpu/possible`: possible_cpu_count - 1
 2. `/sys/devices/system/cpu/online`: online_cpu_count

For a VM with 4 processors, using the default settings (bpf_perf_event_array_exp = 10, bpf_buffer_storage_size = 8), memory usage should be the following:

 1. `buffer_storage_bytes = 6 * (8 * 4096) * 4 = 768 KiB`
 2. `perf_bytes = 1024 * 4 = 4 KiB`

### Performance considerations

For a process with ~25 children, where each child process emits ~30k events in a very short amount of time, using the default values for both the perf event array and the buffer storage structures will fill up everything, causing events to be lost. Different workloads may need even more buffers.

The following considerations are extremely important:

 1. The perf event array must be big enough to handle event bursts. When the buffer is full and events keep coming, they are lost and the kernel will increment a counter to take track of this. The producer/consumer model is very similar to /dev/null, if the consumer is not fast enough the producer will keep working but events will never make it to the consumer.
 2. The ring buffer pools must be big enough to handle bursts of sys_enter events. The size depends on which system calls are actually being captured. Large system calls (i.e.: those that have many large strings associated with them, like the execve call) should be allocated in dedicated pools, to minimize the chance of event loss.
 3. Individual maps have a limited amount of slots. Each slots eventually gets cleared but clearing is performed periodically (either when the map is close to becoming full or when events are dropped). These slots keep the information required to merge the sys_enter and the sys_exit events.

## macOS process and socket auditing

macOS and OS X use OpenBSM for auditing syscalls. osquery uses this system to process file descriptor events, exec events, and socket events.

Auditing on macOS requires a kernel extension. You must either purchase and install a 3rd-party extension or build the extension available in the osquery repository.

At startup, osquery will check if a kernel extension is loaded and accessbile. The checks use very defensive settings so it is possible for them to not detect a correctly installed and running extension. One check is if the audit rules are readable.

The rule add would be more strict at execution time and later installation of the extension may require a restart.

### Using a 3rd-party kernel extension

If you are using a 3rd-party kernel extension, you need to ensure that it forwards system events to user space. Make sure that the vendor's product comes with an auditing daemon. If the daemon is installed and running, osquery should begin receiving events from it, no restart necessary.

A typical installation will include a launch daemon such as: `/Library/LaunchDaemons/com.product.daemon.plist`.
When the process for that daemon is running, osquery should start receiving events.

To test, run:
```
sudo execve /usr/bin/id
```

and look for process_events:
```
osqueryi> select * from process_events;
```

### Using the osquery kernel extension

> **WARNING:** The kernel extension in osquery/kernel requires a `-dev` kernel
> build that has not been released yet. This feature is in development.

```sh
# Download and install the osquery kernel extension.
sudo wget https://s3.amazonaws.com/osquery-packages/osquery.kern.o
sudo cp osquery.kern.o /tmp/osquery.kern.o
sudo kextload -v /tmp/osquery.kern.o
# Optional: automatically load the osquery kernel extension during boot.
sudo cp osquery.kern.o /System/Library/Extensions/osquery.kern.o
```

### Configuring the auditing subsystem

After installing a kernel extension, configure the audit subsystem:

```sh
sudo cp /var/osquery/packs/incident-response.conf /var/osquery/packs/ir.cnf
sudo cp /var/osquery/packs/ossec-rootkit.conf /var/osquery/packs/rk.cnf
sudo mkdir -p /var/osquery/Extensions
sudo cp ./build/darwin/osquery.app/Contents/MacOS/osquery.ext /var/osquery/Extensions/osquery.extension
sudo chmod +x /var/osquery/Extensions/osquery.extension
sudo cp ./tools/deployment/osquery.example.conf /var/osquery/osquery.conf
sudo cp ./tools/deployment/com.facebook.osqueryd.plist /Library/LaunchDaemons/
sudo launchctl load /Library/LaunchDaemons/com.facebook.osqueryd.plist
```

### Understanding the audit settings

You may also run the extension and daemon more manually:

```sh
sudo kextload -v /tmp/osquery.kern.o
osqueryi --extensions_autoload=/etc/osquery/extensions.load --disable_audit=false -S
```

And verify the settings:

```
osqueryi --extensions_autoload=/etc/osquery/extensions.load --disable_audit=false -S
osquery> select * from osquery_flags where name in ("disable_audit");
+----------------+------+---------------------------------------------------+---------------+-------+------------+
| name           | type | description                                       | default_value | value | shell_only |
+----------------+------+---------------------------------------------------+---------------+-------+------------+
| disable_audit  | bool | Disable receiving events from the audit subsystem | true          | false | 0          |
+----------------+------+---------------------------------------------------+---------------+-------+------------+

osquery> select count(1) from process_events;
+----------+
| count(1) |
+----------+
| 0        |
+----------+

osquery> select count(1) from process_events;
+----------+
| count(1) |
+----------+
| 30       |
+----------+
```

### Process Auditing with EndpointSecurity (macOS 10.15+)

Newer versions of macOS (10.15 Catalina and newer) include Apple's EndpointSecurity API, which provides a more reliable and complete mechanism for monitoring process executions and file operations.

#### macOS API Version Compatibility

The EndpointSecurity API has evolved across macOS versions, introducing API changes and new capabilities:

| macOS Version | SDK Changes | New Event Types | Structure Changes |
|---------------|-------------|-----------------|-------------------|
| macOS 10.15 (Catalina) | Initial ES API | Basic process, file events | Original field names (uid, gid) |
| macOS 11 (Big Sur) | Authorization → Authentication<br>ReadDir_Extended → ReadDir | Memory protection events | Field renames (uid → euid, gid → egid) |
| macOS 12 (Monterey) | New socket event types<br>Deprecated path muting functions | Socket, network events | Path field changes in file event structures |
| macOS 13 (Ventura) | New screensharing events | System control, kext events | Extended attribute structure changes |
| macOS 14 (Sonoma) | New XPC, profile events | XPC service monitoring | Target path vs target name changes |

osquery handles these differences through:

1. **Compile-time adaptation:** Conditional code paths based on the SDK version used for compilation
2. **Runtime detection:** Feature probing to identify available ES event types
3. **Field abstraction:** Helper functions to access renamed structure fields
4. **Graceful degradation:** Falling back to available events when newer ones aren't supported

To use EndpointSecurity with osquery:

1. **Enable EndpointSecurity**: 
   ```
   sudo osqueryd --disable_endpointsecurity=false --events_expiry=1
   ```

2. **Sign the binary with proper entitlements**: For development/testing, sign the binary with EndpointSecurity entitlements:
   ```
   codesign --force --sign - --entitlements es_entitlements.xml ./build/osqueryd
   ```

   The entitlements file should contain:
   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
   <plist version="1.0">
   <dict>
       <key>com.apple.developer.endpoint-security.client</key>
       <true/>
   </dict>
   </plist>
   ```

3. **Grant Full Disk Access**: macOS requires explicit user approval for Full Disk Access for applications using EndpointSecurity. You can manually add osquery in System Preferences → Security & Privacy → Privacy → Full Disk Access.

4. **Verify operation**: Query the `es_process_events` table to verify events are being captured:
   ```sql
   SELECT * FROM es_process_events WHERE time > (SELECT unix_time - 3600 FROM time) LIMIT 10;
   ```

#### Version-Specific Behavior and Limitations

- **Network Events**: Socket and network events require macOS 12+ SDK. On systems built with older SDKs, these events will be unavailable.
- **Memory Protection**: The mmap and mprotect events require macOS 11+. Older systems will not report these events.
- **Extended Attributes**: Field access patterns changed in macOS 13+. Builds with older SDKs will use compatibility wrappers.
- **XPC Services**: XPC monitoring requires macOS 14+ and will be automatically disabled on older systems.
- **Authorization Events**: The field name and constant was renamed from Authorization to Authentication in macOS 11+.

### Comprehensive EndpointSecurity Monitoring

Beyond process events, osquery now supports a wide range of security events through the EndpointSecurity framework. The `es_security_events` table provides visibility into:

1. **Authentication Events**:
   - Login window sessions (login, logout, lock, unlock)
   - SSH login/logout
   - Screen sharing connections
   - SU/sudo operations

2. **File System Events**:
   - File operations (create, modify, delete)
   - Permission changes
   - Extended attribute operations

3. **Network Events**:
   - Socket operations
   - Unix domain socket connections
   - XPC service connections

4. **Privilege Operations**:
   - UID/GID changes (setuid, seteuid, etc.)
   - Process control operations (signal, trace)

To enable comprehensive monitoring:

```sh
sudo osqueryd \
  --disable_endpointsecurity=false \
  --es_enable_file_events=true \
  --es_enable_network_events=true \
  --es_enable_auth_events=true \
  --events_expiry=1
```

Query examples:

```sql
-- Monitor authentication events
SELECT * FROM es_security_events 
WHERE category = 'authentication' AND severity = 'high'
ORDER BY time DESC LIMIT 20;

-- Track privilege escalation attempts
SELECT * FROM es_security_events 
WHERE event_type LIKE '%setuid%' 
ORDER BY time DESC;

-- Monitor network connections
SELECT * FROM es_security_events 
WHERE category = 'network' 
ORDER BY time DESC LIMIT 20;
```

### Full Disk Access Authorization

Both the OpenBSM and EndpointSecurity auditing mechanisms require Full Disk Access permissions on macOS.

The recommended approach is to use a configuration profile. First, you'll need the CodeRequirement value for your osquery binary.

To get the appropriate `CodeRequirement` identifier, use the `codesign` tool and then copy everything in the output after the `designated =>`.

```shell
> codesign  -dr - /opt/osquery/lib/osquery.app/Contents/MacOS/osqueryd
Executable=/opt/osquery/lib/osquery.app/Contents/MacOS/osqueryd
designated => identifier "io.osquery.agent" and anchor apple generic and certificate 1[field.1.2.840.113635.100.6.2.6] /* exists */ and certificate leaf[field.1.2.840.113635.100.6.1.13] /* exists */ and certificate leaf[subject.OU] = "3522FA9PXF"
```

For your deployment, either generate an equivalent profile using your MDM dashboard (specifying `/usr/local/bin/osqueryd` as `Identifier` and `path` as the `Identifier Type` and setting `SystemPolicyAllFiles` to `Allow`), or just use the example configuration profile below, ensuring the correct value for the following fields:

- `PayloadOrganization` (your organization)
- `CodeRequirement` (see above)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
 <key>PayloadContent</key>
 <array>
  <dict>
   <key>PayloadDescription</key>
   <string>osqueryd</string>
   <key>PayloadDisplayName</key>
   <string>osqueryd</string>
   <key>PayloadIdentifier</key>
   <string>BDBD19F2-A35A-4AEC-9E96-3CA7E2994666</string>
   <key>PayloadOrganization</key>
   <string>Trail of Bits</string>
   <key>PayloadType</key>
   <string>com.apple.TCC.configuration-profile-policy</string>
   <key>PayloadUUID</key>
   <string>89121197-3B5F-4502-BB8C-4331261D3B8C</string>
   <key>PayloadVersion</key>
   <integer>1</integer>
   <key>Services</key>
   <dict>
    <key>SystemPolicyAllFiles</key>
    <array>
     <dict>
      <key>Allowed</key>
      <true/>
      <key>CodeRequirement</key>
      <string>identifier "io.osquery.agent" and anchor apple generic and certificate 1[field.1.2.840.113635.100.6.2.6] /* exists */ and certificate leaf[field.1.2.840.113635.100.6.1.13] /* exists */ and certificate leaf[subject.OU] = "3522FA9PXF"</string>
      <key>Comment</key>
      <string></string>
      <key>Identifier</key>
      <string>io.osquery.agent</string>
      <key>IdentifierType</key>
      <string>bundleID</string>
     </dict>
    </array>
   </dict>
  </dict>
 </array>
 <key>PayloadDescription</key>
 <string>Allows osquery to access all protected files</string>
 <key>PayloadDisplayName</key>
 <string>Osquery TCC</string>
 <key>PayloadIdentifier</key>
 <string>B663AD53-AF85-4D53-8BF4-F39A0F8DFEFD</string>
 <key>PayloadOrganization</key>
 <string>Trail of Bits</string>
 <key>PayloadRemovalDisallowed</key>
 <false/>
 <key>PayloadScope</key>
 <string>System</string>
 <key>PayloadType</key>
 <string>Configuration</string>
 <key>PayloadUUID</key>
 <string>3C1BD05B-C1F2-41AC-BF55-F0BE50267280</string>
 <key>PayloadVersion</key>
 <integer>1</integer>
</dict>
</plist>
```

## Tuning the event system

### Improving performance through optimizations and filtering

This section provides a brief overview of common and recommended
optimizations for event-based tables. These optimizations also apply
to the FIM events.

1. `--events_optimize=true` apply optimizations when `SELECT`ing from events-based tables, enabled by default.
2. `--events_expiry` the lifetime of buffered events in seconds with a default value of 86000.
3. `--events_max` the maximum number of events to store in the buffer before expiring them with a default value of 1000.

The goal of optimizations are to protect the running process and system from impacting performance. By default these are all enabled, which is good for configuration and performance, but may introduce inconsistencies on highly-stressed systems using process auditing.

Optimizations work best when `SELECT`ing often from event-based tables. Otherwise the events are in a buffered state. When an event-based table is selected within the daemon, the backing storage maintaining event data is cleared according to the `--event_expiry` lifetime. Setting this value to `1` will auto-clear events whenever a `SELECT` is performed against the table, reducing all impact of the buffer.

### Comprehensive EndpointSecurity event coverage

By default, osquery's EndpointSecurity integration only captures basic process lifecycle events (exec, fork, exit). However, the EndpointSecurity framework provides access to many more event types that can be valuable for security monitoring and threat detection.

osquery now supports an opt-in model to enable additional event categories:

```
# Basic process events (enabled by default with --disable_endpointsecurity=false)
--disable_endpointsecurity=false

# Enable all authorization-related events (setuid, seteuid, etc.)
--enable_es_auth_events=true

# Enable network events (socket binding and connections)
--enable_es_network_events=true 

# Enable file system events beyond basic FIM (mount, unmount, etc.)
--enable_es_file_events=true

# Enable remote thread creation events (detect code injection)
--enable_es_remote_thread_events=true

# Enable screen sharing connection events (macOS 13.0+)
--enable_es_screensharing_events=true

# Enable profile management events (macOS 14.0+)
--enable_es_profile_events=true

# Enable authentication events (SSH login, su, sudo, etc.)
--enable_es_authentication_events=true

# Enable XPC connection events (macOS 14.0+)
--enable_es_xpc_events=true

# Alternatively, enable specific event types for fine-grained control
--es_enabled_events="notify_mount,notify_unmount,notify_setuid,notify_authentication"
```

#### SDK Version-Aware Configuration

The availability of certain events depends on the SDK version used to build osquery. The implementation includes version checks to ensure compatibility:

```cpp
// Enable events based on SDK version availability
#if defined(MAC_OS_X_VERSION_10_15)
  // Basic process events available in 10.15+
  events.push_back(ES_EVENT_TYPE_NOTIFY_EXEC);
  events.push_back(ES_EVENT_TYPE_NOTIFY_FORK);
  events.push_back(ES_EVENT_TYPE_NOTIFY_EXIT);
#endif

#if defined(MAC_OS_VERSION_11_0) || MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
  // Memory protection events available in macOS 11+
  if (FLAGS_enable_es_memory_events) {
    events.push_back(ES_EVENT_TYPE_NOTIFY_MMAP);
    events.push_back(ES_EVENT_TYPE_NOTIFY_MPROTECT);
  }
  
  // Authentication events were renamed in macOS 11
  events.push_back(ES_EVENT_TYPE_NOTIFY_AUTHENTICATION);
#elif defined(MAC_OS_X_VERSION_10_15)
  // Fall back to authorization events on older SDKs
  events.push_back(ES_EVENT_TYPE_NOTIFY_AUTHORIZATION);
#endif

#if defined(MAC_OS_VERSION_12_0) || MAC_OS_X_VERSION_MAX_ALLOWED >= 120000
  // Socket events available in macOS 12+
  if (FLAGS_enable_es_network_events) {
    events.push_back(ES_EVENT_TYPE_NOTIFY_SOCKET);
    events.push_back(ES_EVENT_TYPE_NOTIFY_CONNECT);
    // Additional socket events...
  }
#endif
```

For any macOS version, osquery will enable the maximum set of events available for that version and gracefully handle missing events at runtime.