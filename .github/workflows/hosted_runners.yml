#
# Copyright (c) 2014-present, The osquery authors
#
# This source code is licensed as defined by the LICENSE file found in the
# root directory of this source tree.
#
# SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)
#

# Due to a limitation in how GitHub Actions works, we can't reference
# jobs in another file inside the `needs` statement.
#
# This configuration file takes care of the Windows, macOS and Linux
# builds on the x86 platform.
name: build_x86

on:
  # Run this workflow once every day against the master branch
  schedule:
   - cron: "0 7 * * *"

  push:
    branches:
      - 'master'
      - 'main'

    tags:
      - '*'

  pull_request:
    branches:
      - '*'

# Cancel old jobs of a PR if a new job is started.
# Fallback on using the run id if it's not a PR, which is unique, so no job canceling.
concurrency:
  group: hosted-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

# Please remember to update values for both x86 and aarch64 workflows.
env:
  PACKAGING_REPO: https://github.com/osquery/osquery-packaging
  PACKAGING_COMMIT: c089fb2d3d796d976e3b2fbea7ee69a1616b9576
  SUBMODULE_CACHE_VERSION: 3

# If the initial code sanity checks are passing, then one job
# per [`platform` * `build_type`] will start, building osquery
# and generating packages that are later attached to the commit
# (or PR) as build artifacts.
jobs:
  # This job performs basic source code check, looking for formatting
  # issues and missing copyright headers
  check_code_style:
    runs-on: ubuntu-22.04

    container:
      image: osquery/builder20.04:7e9ee0339
      options: --user 1001

    steps:
    - name: Setup the build paths
      shell: bash
      id: build_paths
      run: |
        rel_build_path="workspace/build"
        rel_source_path="workspace/src"

        mkdir -p "${rel_build_path}"
        mkdir -p "${rel_source_path}"

        echo "SOURCE=$(realpath ${rel_source_path})" >> $GITHUB_OUTPUT
        echo "BINARY=$(realpath ${rel_build_path})" >> $GITHUB_OUTPUT

    - name: Clone the osquery repository
      uses: actions/checkout@v4
      with:
        path: ${{ steps.build_paths.outputs.SOURCE }}
        fetch-depth: 0

    # This script makes sure that the copyright headers have been correctly
    # placed on all the source code files
    - name: Check the copyright headers
      working-directory: ${{ steps.build_paths.outputs.SOURCE }}
      run: |
        ./tools/ci/scripts/check_copyright_headers.py

    - name: Configure the project
      working-directory: ${{ steps.build_paths.outputs.BINARY }}
      run: |
        cmake -G "Unix Makefiles" \
          -DOSQUERY_TOOLCHAIN_SYSROOT:PATH="/usr/local/osquery-toolchain" \
          -DOSQUERY_ENABLE_FORMAT_ONLY=ON \
          "${{ steps.build_paths.outputs.SOURCE }}"

    # Formatting is tested against the clang-format binary we ship
    # with the osquery-toolchain, so this job is only performed once on
    # a Linux machine.
    - name: Check code formatting
      working-directory: ${{ steps.build_paths.outputs.BINARY }}
      run:
        cmake --build . --target format_check



  # This jobs checks that the third party libraries manifest has the correct format
  # and that is up to date compared to the current state of the repository
  check_libraries_manifest:
    runs-on: ubuntu-22.04

    steps:
    - name: Clone the osquery repository
      uses: actions/checkout@v4

    - name: Install python pre-requisites
      run: |
        pip3 install -r ./tools/ci/scripts/cve/requirements.txt

    - name: Verify the third party libraries manifest
      run: |
        ./tools/ci/scripts/cve/validate_manifest_libraries_versions.py --manifest libraries/third_party_libraries_manifest.json \
        --repository .


  # Test generating the website json
  check_genwebsitejson:
    needs: [check_code_style, check_libraries_manifest]
    runs-on: ubuntu-22.04

    steps:
    - name: Clone the osquery repository
      uses: actions/checkout@v4

    - name: genwebsitejson.py
      run: python3 tools/codegen/genwebsitejson.py --specs=specs/


  # This job runs source code analysis tools (currently, just cppcheck)
  check_source_code:
    needs: [check_code_style, check_libraries_manifest]

    runs-on: ${{ matrix.os }}

    container:
      image: osquery/builder20.04:7e9ee0339
      options: --user 1001

    strategy:
      matrix:
        os: [ubuntu-22.04]

    steps:
    - name: Setup the build paths
      shell: bash
      id: build_paths
      run: |
        rel_build_path="workspace/build"
        rel_source_path="workspace/src"
        rel_install_path="workspace/install"

        mkdir -p ${rel_build_path} \
                 ${rel_source_path} \
                 ${rel_install_path}

        echo "SOURCE=$(realpath ${rel_source_path})" >> $GITHUB_OUTPUT
        echo "BINARY=$(realpath ${rel_build_path})" >> $GITHUB_OUTPUT
        echo "REL_BINARY=${rel_build_path}" >> $GITHUB_OUTPUT

    - name: Clone the osquery repository
      uses: actions/checkout@v4
      with:
        path: ${{ steps.build_paths.outputs.SOURCE }}
        fetch-depth: 0

    - name: Update the cache (git submodules)
      uses: actions/cache@v4
      with:
        path: ${{ steps.build_paths.outputs.SOURCE }}/.git/modules

        key: |
          gitmodules_${{ matrix.os }}_${{env.SUBMODULE_CACHE_VERSION}}_${{ github.sha }}

        restore-keys: |
          gitmodules_${{ matrix.os }}_${{env.SUBMODULE_CACHE_VERSION}}

    - name: Update the git submodules
      working-directory: ${{ steps.build_paths.outputs.SOURCE }}
      run: |
        git submodule sync --recursive

    - name: Configure the project (Release)
      working-directory: ${{ steps.build_paths.outputs.BINARY }}

      run: |
        cmake -G "Unix Makefiles" \
          -DOSQUERY_TOOLCHAIN_SYSROOT:PATH="/usr/local/osquery-toolchain" \
          -DCMAKE_BUILD_TYPE:STRING=Release \
          -DOSQUERY_BUILD_TESTS=ON \
          -DOSQUERY_BUILD_ROOT_TESTS=ON \
          "${{ steps.build_paths.outputs.SOURCE }}"

    - name: Initialize the project (Release)
      working-directory: ${{ steps.build_paths.outputs.BINARY }}
      run: |
        cmake --build . --target prepare_for_ide

    - name: Run cppcheck (Release)
      shell: bash
      id: release_cppcheck_runner
      working-directory: ${{ steps.build_paths.outputs.BINARY }}
      run: |
        cmake --build . --target cppcheck 2>&1 | tee cppcheck_release.txt

    - name: Store the cppcheck log (Release)
      uses: actions/upload-artifact@v4.4.0
      with:
        name: cppcheck-release
        path: ${{ steps.build_paths.outputs.REL_BINARY }}/cppcheck_release.txt

    - name: Configure the project (Debug)
      working-directory: ${{ steps.build_paths.outputs.BINARY }}

      run: |
        cmake -G "Unix Makefiles" \
          -DOSQUERY_TOOLCHAIN_SYSROOT:PATH="/usr/local/osquery-toolchain" \
          -DCMAKE_BUILD_TYPE:STRING=Debug \
          -DOSQUERY_BUILD_TESTS=ON \
          -DOSQUERY_BUILD_ROOT_TESTS=ON \
          "${{ steps.build_paths.outputs.SOURCE }}"

    - name: Initialize the project (Debug)
      working-directory: ${{ steps.build_paths.outputs.BINARY }}
      run: |
        cmake --build . --target prepare_for_ide

    - name: Run cppcheck (Debug)
      shell: bash
      id: debug_cppcheck_runner
      working-directory: ${{ steps.build_paths.outputs.BINARY }}
      run: |
        cmake --build . --target cppcheck 2>&1 | tee cppcheck_debug.txt

    - name: Store the cppcheck log (Debug)
      uses: actions/upload-artifact@v4.4.0
      with:
        name: cppcheck-debug
        path: ${{ steps.build_paths.outputs.REL_BINARY }}/cppcheck_debug.txt

  # The Windows build will only start once we know that the code
  # has been properly formatted
  build_windows:
    needs: [check_code_style, check_libraries_manifest]

    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        build_type: [RelWithDebInfo]
        bitness: [64, arm64]
        os: [windows-2022]

    steps:
    - name: Select the build job count
      shell: powershell
      id: build_job_count
      run: |
        $cores=(Get-CIMInstance Win32_ComputerSystem).NumberOfLogicalProcessors + 1
        echo "VALUE=$cores" >> $env:GITHUB_OUTPUT

    - name: Setup the build paths
      shell: powershell
      id: build_paths
      run: |
        $rel_src_path = "w\src"
        $rel_build_path = "w\build"
        $rel_sccache_path = "w\sccache"
        $rel_downloads_path = "w\downloads"
        $rel_install_path = "w\install"
        $rel_package_data_path = "w\package_data"
        $rel_packaging_path = "w\osquery-packaging"
        $rel_packaging_build = "w\package-build"

        New-Item -ItemType Directory -Force -Path $rel_build_path
        New-Item -ItemType Directory -Force -Path $rel_sccache_path
        New-Item -ItemType Directory -Force -Path $rel_downloads_path
        New-Item -ItemType Directory -Force -Path $rel_install_path
        New-Item -ItemType Directory -Force -Path $rel_package_data_path
        New-Item -ItemType Directory -Force -Path $rel_packaging_build

        $base_dir = (Get-Item .).FullName

        echo "SOURCE=$base_dir\$rel_src_path" >> $env:GITHUB_OUTPUT
        echo "REL_SOURCE=$rel_src_path" >> $env:GITHUB_OUTPUT
        echo "BINARY=$base_dir\$rel_build_path" >> $env:GITHUB_OUTPUT
        echo "SCCACHE=$base_dir\$rel_sccache_path" >> $env:GITHUB_OUTPUT
        echo "DOWNLOADS=$base_dir\$rel_downloads_path" >> $env:GITHUB_OUTPUT
        echo "INSTALL=$base_dir\$rel_install_path" >> $env:GITHUB_OUTPUT
        echo "PACKAGING=$base_dir\$rel_packaging_path" >> $env:GITHUB_OUTPUT
        echo "PACKAGE_DATA=$base_dir\$rel_package_data_path" >> $env:GITHUB_OUTPUT
        echo "PACKAGE_BUILD=$base_dir\$rel_packaging_build" >> $env:GITHUB_OUTPUT

    - name: Setup the VC arch
      shell: powershell
      id: vc_arch
      run: |
        $arch = switch ("${{ matrix.bitness }}")
        {
            "64" { "x64" }
            "arm64" { "x64_arm64" }
        }
        echo "VC_ARCH=$arch" >> $env:GITHUB_OUTPUT

    # Symbolic links are supported by default on Linux and macOS. On
    # Windows, we have to enable them explicitly. They are used to
    # handle the include header namespace support that came with
    # the initial Buck build system refactor
    - name: Configure git
      run: |
        git config --global core.autocrlf false
        git config --global core.symlinks true

    - name: Clone the osquery repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        path: ${{ steps.build_paths.outputs.REL_SOURCE }}

    - name: Get runner hardware info
      id: runner_stats
      shell: powershell
      run: |
        Get-CIMInstance Win32_LogicalDisk
        Get-CIMInstance Win32_ComputerSystem | Select-Object -Property NumberOfLogicalProcessors
        Get-CIMInstance Win32_ComputerSystem | Select-Object -Property TotalPhysicalMemory

    - name: Detect the osquery version
      shell: powershell
      id: osquery_version
      run: |
        cd ${{ steps.build_paths.outputs.SOURCE }}
        $osquery_version=$(git describe --tags --abbrev=0)

        echo "VALUE=$osquery_version" >> $env:GITHUB_OUTPUT

    - name: Clone the osquery-packaging repository
      run: |
        cd w
        git clone ${{ env.PACKAGING_REPO }}
        cd ${{ steps.build_paths.outputs.PACKAGING }}
        git checkout ${{ env.PACKAGING_COMMIT }}

    - name: Update the cache (git submodules)
      uses: actions/cache@v4
      with:
        path: ${{ steps.build_paths.outputs.SOURCE }}\.git\modules

        key: |
          gitmodules_${{ matrix.os }}_${{env.SUBMODULE_CACHE_VERSION}}_${{ github.sha }}

        restore-keys: |
          gitmodules_${{ matrix.os }}_${{env.SUBMODULE_CACHE_VERSION}}

    - name: Update the cache (downloads)
      uses: actions/cache@v4
      with:
        path: ${{ steps.build_paths.outputs.DOWNLOADS }}

        key: |
          downloads_${{ matrix.os }}_${{ github.sha }}

        restore-keys: |
          downloads_${{ matrix.os }}

    - name: Initialize the Python 3 installation
      uses: actions/setup-python@v5
      with:
        python-version: "3.13.x"
        architecture: x64

    # The runners will likely have both the x86 and x64 versions of
    # Python but we always need the 64-bit one regardless of which
    # architecture we are building for.
    #
    # The setup-python action should have put the right Python version
    # in the PATH variable for us, so locate the installation directory
    # so we can use it as a hint when we configure the project with
    # CMake
    - name: Locate the Python root directory
      id: python_root_directory
      shell: powershell
      run: |
        $python_executable_path = $(Get-Command python.exe | Select-Object -ExpandProperty Definition)
        $python_root_directory = (Get-Item $python_executable_path).Directory.FullName

        echo "VALUE=$python_root_directory" >> $env:GITHUB_OUTPUT

    # Install the Python dependencies needed for our testing framework
    - name: Install tests prerequisites
      run: |
        python -m pip install --upgrade pip

        python -m pip install wheel `
                              setuptools `
                              psutil `
                              timeout_decorator `
                              thrift==0.11.0 `
                              osquery `
                              pywin32

    - name: Install Strawberry Perl
      working-directory: ${{ steps.build_paths.outputs.SOURCE }}
      shell: powershell
      run: |
        tools\ci\scripts\install_openssl_formula_dependencies.ps1

    # TODO: Implement a cache so we don't keep hitting the server at each run
    - name: Install CMake
      working-directory: ${{ steps.build_paths.outputs.DOWNLOADS }}
      shell: powershell
      run: |
        $long_cmake_ver = "3.21.4"
        $short_cmake_ver = $($long_cmake_ver.split(".")[0] + "." + $long_cmake_ver.split(".")[1])

        $folder_name = $("cmake-" + $long_cmake_ver + "-windows-x86_64")
        $archive_name = $($folder_name + ".zip")

        $url = $("https://cmake.org/files/v" + $short_cmake_ver + "/" + $archive_name)

        (New-Object System.Net.WebClient).DownloadFile($url, $archive_name)
        7z x -o${{ steps.build_paths.outputs.INSTALL }} -y $archive_name

        echo "${{ steps.build_paths.outputs.INSTALL }}\$folder_name\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

    # TODO: Implement a cache so we don't keep hitting the server at each run
    - name: Install sccache
      working-directory: ${{ steps.build_paths.outputs.DOWNLOADS }}
      shell: powershell
      run: |
        $long_version = "0.0.1"

        $archive_name = $("sccache-" + $long_version + "-windows.7z")
        $url = $("https://github.com/osquery/sccache/releases/download/" + $long_version + "-osquery/" + $archive_name)

        (New-Object System.Net.WebClient).DownloadFile($url, $archive_name)
        7z x -o${{ steps.build_paths.outputs.INSTALL }}\sccache -y $archive_name

        echo "${{ steps.build_paths.outputs.INSTALL }}\sccache" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

    # TODO: Implement a cache so we don't keep hitting the server at each run
    - name: Install Ninja
      working-directory: ${{ steps.build_paths.outputs.DOWNLOADS }}
      shell: powershell
      run: |
        $long_version = "1.10.0"

        $archive_name = "ninja-win.zip"
        $url = $("https://github.com/ninja-build/ninja/releases/download/v" + $long_version + "/" + $archive_name)

        (New-Object System.Net.WebClient).DownloadFile($url, $archive_name)
        7z x -o${{ steps.build_paths.outputs.INSTALL }}\ninja -y $archive_name

        echo "${{ steps.build_paths.outputs.INSTALL }}\ninja" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

    - name: Configure the project
      shell: cmd
      working-directory: ${{ steps.build_paths.outputs.BINARY }}

      env:
        SCCACHE_DIR: ${{ steps.build_paths.outputs.SCCACHE }}
        SCCACHE_CACHE_SIZE: "5G"

      run: |
        call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat" ${{ steps.vc_arch.outputs.VC_ARCH }}
        @echo on

        set cross_compilation=
        if ${{ matrix.bitness }}==arm64 (
            echo set (CMAKE_SYSTEM_NAME Windows^) > cross.cmake
            echo set (CMAKE_SYSTEM_PROCESSOR ARM64^) >> cross.cmake
            set cross_compilation=-DCMAKE_TOOLCHAIN_FILE=cross.cmake
        )

        cmake -G Ninja ^
          -DCMAKE_C_COMPILER=cl.exe ^
          -DCMAKE_CXX_COMPILER=cl.exe ^
          -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} ^
          -DOSQUERY_BUILD_TESTS=ON ^
          -DCMAKE_C_COMPILER_LAUNCHER="sccache.exe" ^
          -DCMAKE_CXX_COMPILER_LAUNCHER="sccache.exe" ^
          -DPython3_ROOT_DIR=${{ steps.python_root_directory.outputs.VALUE }} ^
          ${{ steps.build_paths.outputs.SOURCE }} ^
          %cross_compilation%

    - name: Determine compiler version
      id: determine_compiler_version
      shell: pwsh
      run: |
        $compiler = (Get-Content "${{ steps.build_paths.outputs.BINARY }}\CMakeCache.txt" | Select-String -Pattern "CMAKE_CXX_COMPILER:STRING=(.*)").Matches[0].Groups[1].Value

        echo "Compiler configured by CMake is $compiler"

        if ($compiler -eq $null || $compiler -eq "") {
          Write-Error "Could not find the configured compiler" -ErrorAction Stop
        }

        <#
           We run the compiler help option; the compiler will write its version in stderr.
           Due to how powershell works, we have to go through some hoops to extract the stderr to a variable
           and also avoid it considering the command as failed because stderr contains messages.
           The expression runs the compiler in a subshell, discards its stdout, then the stderr of the subshell is redirected
           to the stdout of the parent shell.
        #>
        $ErrorActionPreference = 'Continue'
        $erroutput = $( & "$compiler" /? 1>$null ) 2>&1
        $ErrorActionPreference = 'Stop'

        if ($erroutput -eq $null || $erroutput -eq "") {
          Write-Error "Failed to run the compiler at $compiler" -ErrorAction Stop
        }

        $version = ($erroutput | Select-String -Pattern "Compiler Version (.*) for").Matches[0].Groups[1].Value.Replace(".", "")

        if ($version -eq $null || $version -eq "") {
          Write-Error "Failed to determine compiler version for $compiler and output $erroutput" -ErrorAction Stop
        }

        echo "Found compiler version $version"

        echo "COMPILER_VERSION=$version" >> $env:GITHUB_OUTPUT

    - name: Update the cache (sccache)
      uses: actions/cache@v4
      with:
        path: ${{ steps.build_paths.outputs.SCCACHE }}

        key: |
          sccache_${{ matrix.os }}_${{ matrix.bitness }}_${{ matrix.build_type }}_${{ steps.determine_compiler_version.outputs.COMPILER_VERSION }}_${{ github.sha }}

        restore-keys: |
          sccache_${{ matrix.os }}_${{ matrix.bitness }}_${{ matrix.build_type }}_${{ steps.determine_compiler_version.outputs.COMPILER_VERSION }}

    - name: Build the project
      shell: cmd
      working-directory: ${{ steps.build_paths.outputs.BINARY }}

      env:
        SCCACHE_DIR: ${{ steps.build_paths.outputs.SCCACHE }}
        SCCACHE_CACHE_SIZE: "5G"

      run: |
        call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat" ${{ steps.vc_arch.outputs.VC_ARCH }}
        @echo on

        cmake --build . -j ${{ steps.build_job_count.outputs.VALUE }}

        if %errorlevel% neq 0 exit /b %errorlevel%
        sccache.exe --stop-server

    - name: Disk space information
      id: disk_space_info_post_build
      shell: powershell
      run: |
        Get-CIMInstance Win32_LogicalDisk
        $bindir_size = (Get-ChildItem -Path ${{ steps.build_paths.outputs.BINARY }} -Recurse | Measure-Object -Property Length -Sum).sum / 1MB
        echo "Binary dir size: $bindir_size MBs"

    - name: Run the tests
      # arm64 tests can't be run on x64 machine
      if: matrix.bitness != 'arm64'
      working-directory: ${{ steps.build_paths.outputs.BINARY }}
      shell: cmd
      run: |
        call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat" ${{ steps.vc_arch.outputs.VC_ARCH }}
        @echo on
        ctest --build-nocmake -C Release -V

    - name: Run the install target
      working-directory: ${{ steps.build_paths.outputs.BINARY }}

      env:
        CCACHE_DIR: ${{ steps.build_paths.outputs.SCCACHE }}
        DESTDIR: ${{ steps.build_paths.outputs.PACKAGE_DATA }}

      run: |
        cmake --build . --target install -j 3

    - name: Create the packages
      working-directory: ${{ steps.build_paths.outputs.PACKAGE_BUILD }}
      shell: cmd

      run: |
        call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat" ${{ steps.vc_arch.outputs.VC_ARCH }}
        @echo on

        7z ^
          a windows_package_data.zip ^
          ${{ steps.build_paths.outputs.PACKAGE_DATA }}

        if %errorlevel% neq 0 exit /b %errorlevel%

        if ${{ matrix.bitness }}==arm64 (
           echo Do not create other packages for arm64
           exit 0
        )

        cmake -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} ^
          -DCPACK_GENERATOR=WIX ^
          -DOSQUERY_PACKAGE_VERSION=${{ steps.osquery_version.outputs.VALUE }} ^
          -DOSQUERY_DATA_PATH=${{ steps.build_paths.outputs.PACKAGE_DATA }} ^
          -DOSQUERY_BITNESS=${{ matrix.bitness }} ^
          ${{ steps.build_paths.outputs.PACKAGING }}

        if %errorlevel% neq 0 exit /b %errorlevel%

        cmake --build . ^
          --config Release ^
          --target package

        if %errorlevel% neq 0 exit /b %errorlevel%

        cmake -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} ^
          -DCPACK_GENERATOR=NuGet ^
          -DOSQUERY_PACKAGE_VERSION=${{ steps.osquery_version.outputs.VALUE }} ^
          -DOSQUERY_DATA_PATH=${{ steps.build_paths.outputs.PACKAGE_DATA }} ^
          -DOSQUERY_BITNESS=${{ matrix.bitness }} ^
          ${{ steps.build_paths.outputs.PACKAGING }}

        if %errorlevel% neq 0 exit /b %errorlevel%

        cmake --build . ^
          --config Release ^
          --target package

        if %errorlevel% neq 0 exit /b %errorlevel%

    - name: Locate the packages
      id: packages
      shell: powershell
      run: |
        echo "REL_UNSIGNED_RELEASE_PACKAGE_DATA_PATH=$((ls ${{ steps.build_paths.outputs.PACKAGE_BUILD }}\*.zip).FullName)" >> $env:GITHUB_OUTPUT
        echo "REL_UNSIGNED_RELEASE_MSI_PATH=$((ls ${{ steps.build_paths.outputs.PACKAGE_BUILD }}\*.msi).FullName)" >> $env:GITHUB_OUTPUT
        echo "REL_UNSIGNED_RELEASE_NUPKG_PATH=$((ls ${{ steps.build_paths.outputs.PACKAGE_BUILD }}\*.nupkg).FullName)" >> $env:GITHUB_OUTPUT

    - name: Store the unsigned release package data artifact
      uses: actions/upload-artifact@v4.4.0
      with:
        name: windows${{ matrix.bitness }}_unsigned_release_package_data
        path: ${{ steps.packages.outputs.REL_UNSIGNED_RELEASE_PACKAGE_DATA_PATH }}

    - name: Store the unsigned release MSI artifact
      if: matrix.bitness != 'arm64'
      uses: actions/upload-artifact@v4.4.0
      with:
        name: windows${{ matrix.bitness }}_unsigned_release_msi
        path: ${{ steps.packages.outputs.REL_UNSIGNED_RELEASE_MSI_PATH }}

    - name: Store the unsigned release NUPKG artifact
      if: matrix.bitness != 'arm64'
      uses: actions/upload-artifact@v4.4.0
      with:
        name: windows${{ matrix.bitness }}_unsigned_release_nupkg
        path: ${{ steps.packages.outputs.REL_UNSIGNED_RELEASE_NUPKG_PATH }}

    # Before we terminate this job, delete the build folder. The cache
    # actions will require the disk space to create the archives.
    - name: Reclaim disk space
      shell: powershell
      run: |
        rm -r -Force ${{ steps.build_paths.outputs.BINARY }}

  # This job is here as a github status check -- it allows us to move the dependency from
  # being on all the jobs to this single one.
  mergeable:
    runs-on: ubuntu-latest
    steps:
      - run: true
    needs:
      - build_windows
      - check_source_code
